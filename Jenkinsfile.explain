// ============================================================================
// JENKINSFILE COMMENT√â EN D√âTAIL
// Langage : Groovy (syntaxe Declarative Pipeline)
// ============================================================================

// 'pipeline' = Mot-cl√© de d√©but obligatoire pour un pipeline d√©claratif
pipeline {
    
    // ========================================================================
    // AGENT : O√π le pipeline s'ex√©cute
    // ========================================================================
    agent any
    // 'any' = N'importe quel agent disponible (master ou worker)
    // Alternatives :
    //   agent { docker { image 'python:3.11' } }  ‚Üí Lance tout dans un conteneur
    //   agent { label 'linux' }                   ‚Üí Agent avec le label 'linux'
    //   agent none                                ‚Üí Pas d'agent global, d√©fini par stage
    
    
    // ========================================================================
    // ENVIRONMENT : Variables d'environnement globales
    // ========================================================================
    environment {
        // Variables disponibles dans TOUS les stages
        DOCKER_IMAGE = 'mlops-training'
        // ${env.BUILD_NUMBER} = Variable Jenkins automatique (1, 2, 3...)
        VERSION = "${env.BUILD_NUMBER}"
        
        // Exemple d'autres variables possibles :
        // DATABASE_URL = 'postgresql://...'
        // API_KEY = credentials('my-api-key')  ‚Üí R√©cup√®re depuis Jenkins Credentials
    }
    
    
    // ========================================================================
    // OPTIONS : Configuration du pipeline
    // ========================================================================
    options {
        // Garder seulement les 10 derniers builds (√©conomise de l'espace)
        buildDiscarder(logRotator(numToKeepStr: '10'))
        
        // Si le pipeline prend plus de 30 minutes, l'arr√™ter automatiquement
        timeout(time: 30, unit: 'MINUTES')
        // Autres unit√©s possibles : SECONDS, HOURS, DAYS
        
        // Ajouter un timestamp √† chaque ligne de log
        timestamps()
        // Exemple de log : [2025-01-14 10:30:45] Building...
        
        // Autres options utiles :
        // disableConcurrentBuilds()  ‚Üí Emp√™che 2 builds simultan√©s
        // skipDefaultCheckout()      ‚Üí Ne pas faire checkout automatique
        // retry(3)                   ‚Üí R√©essayer 3 fois en cas d'√©chec
    }
    
    
    // ========================================================================
    // STAGES : √âtapes du pipeline (c'est le c≈ìur !)
    // ========================================================================
    stages {
        
        // ====================================================================
        // STAGE 1 : Checkout (R√©cup√©ration du code)
        // ====================================================================
        stage('üì• Checkout') {
            // 'steps' = Actions √† ex√©cuter dans ce stage
            steps {
                // 'echo' = Afficher un message dans les logs
                echo '=== R√©cup√©ration du code depuis Git ==='
                
                // 'checkout scm' = R√©cup√®re le code depuis Git configur√© dans le job
                // scm = Source Code Management (Git, SVN, etc.)
                checkout scm
                
                // 'script' = Permet d'utiliser du code Groovy (syntaxe script√©e)
                script {
                    // Ex√©cuter une commande shell et capturer le r√©sultat
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",  // Commande shell
                        returnStdout: true                      // Retourner la sortie
                    ).trim()  // Enlever les espaces/newlines
                    
                    // Maintenant env.GIT_COMMIT_SHORT = "a1b2c3d" (hash court du commit)
                }
                
                // Afficher des infos avec interpolation de variables
                echo "üìå Commit: ${env.GIT_COMMIT_SHORT}"
                // ${env.BRANCH_NAME ?: 'main'} = Si BRANCH_NAME existe, l'afficher, sinon 'main'
                echo "üìå Branch: ${env.BRANCH_NAME ?: 'main'}"
                echo "üìå Build: #${env.BUILD_NUMBER}"
            }
        }
        
        
        // ====================================================================
        // STAGE 2 : Code Quality (Linting)
        // ====================================================================
        stage('üîç Code Quality') {
            steps {
                echo '=== Analyse de la qualit√© du code ==='
                
                script {
                    // Utiliser l'API Docker de Jenkins (plugin Docker Pipeline requis)
                    // docker.image('...').inside { } = Lance un conteneur temporaire
                    docker.image('python:3.11-slim').inside {
                        // Tout ce qui est dans ce bloc s'ex√©cute DANS le conteneur
                        
                        // 'sh' = Execute shell (comme bash)
                        // Les ''' (triple quotes) permettent le multi-ligne
                        sh '''
                            # Installer les outils (dans le conteneur)
                            pip install flake8 black --quiet
                            
                            echo "üîç Linting avec flake8..."
                            # || true = Ne pas √©chouer le build si flake8 trouve des erreurs
                            flake8 . --max-line-length=120 --exclude=venv,__pycache__ || true
                            
                            echo "üé® V√©rification du formatage avec black..."
                            # || echo = Afficher un warning au lieu d'√©chouer
                            black --check . || echo "‚ö†Ô∏è Code pas format√©"
                        '''
                        
                        // Une fois sorti du bloc, le conteneur est d√©truit (--rm auto)
                    }
                }
            }
        }
        
        
        // ====================================================================
        // STAGE 3 : Tests
        // ====================================================================
        stage('üß™ Tests') {
            steps {
                echo '=== Ex√©cution des tests ==='
                
                script {
                    // Nouveau conteneur Python pour les tests
                    docker.image('python:3.11-slim').inside {
                        sh '''
                            # Installer les d√©pendances du projet
                            pip install -r requirements.txt --quiet
                            pip install pytest pytest-cov --quiet
                            
                            # Cr√©er un dossier pour les rapports
                            mkdir -p reports
                            
                            echo "üß™ Lancement des tests..."
                            # pytest avec options :
                            pytest test_app.py -v \
                                --junitxml=reports/junit.xml \           # Format JUnit pour Jenkins
                                --cov=. \                                # Couverture de code
                                --cov-report=html \                      # Rapport HTML
                                --cov-report=term-missing                # Afficher les lignes non test√©es
                        '''
                    }
                }
            }
            
            // 'post' = Actions √† ex√©cuter APR√àS le stage (succ√®s ou √©chec)
            post {
                // 'always' = Toujours ex√©cuter (m√™me si √©chec)
                always {
                    // Publier les r√©sultats des tests dans Jenkins
                    // Jenkins va parser le XML et afficher les stats
                    junit 'reports/junit.xml'
                    
                    // Publier le rapport HTML de couverture
                    publishHTML([
                        reportDir: 'htmlcov',           // Dossier contenant le rapport
                        reportFiles: 'index.html',       // Page d'entr√©e
                        reportName: 'Code Coverage',     // Nom dans Jenkins
                        keepAll: true                    // Garder tous les rapports
                    ])
                }
                
                // Autres options post possibles :
                // success { ... }  ‚Üí Seulement si succ√®s
                // failure { ... }  ‚Üí Seulement si √©chec
            }
        }
        
        
        // ====================================================================
        // STAGE 4 : Build Docker Image
        // ====================================================================
        stage('üê≥ Build Docker Image') {
            steps {
                echo '=== Construction de l\'image Docker ==='
                
                script {
                    // """ (double quotes) = Permet l'interpolation de variables
                    // ''' (simple quotes) = Pas d'interpolation
                    sh """
                        # docker build avec plusieurs tags
                        docker build \
                            -t ${DOCKER_IMAGE}:${VERSION} \              # Tag avec num√©ro de build
                            -t ${DOCKER_IMAGE}:latest \                  # Tag 'latest'
                            --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                            --build-arg VCS_REF=${env.GIT_COMMIT_SHORT} \
                            .
                        
                        # \$(date ...) = \$ √©chappe le $ pour √©viter interpolation Groovy
                        # On veut que date s'ex√©cute dans le shell, pas dans Groovy
                    """
                    
                    echo "‚úÖ Image cr√©√©e: ${DOCKER_IMAGE}:${VERSION}"
                    
                    // Lister les images Docker cr√©√©es
                    sh "docker images | grep ${DOCKER_IMAGE}"
                }
            }
        }
        
        
        // ====================================================================
        // STAGE 5 : Security Scan (Optionnel)
        // ====================================================================
        stage('üîê Security Scan') {
            steps {
                echo '=== Scan de s√©curit√© de l\'image ==='
                
                script {
                    sh """
                        echo "üîç Scan de vuln√©rabilit√©s..."
                        
                        # Comment√© pour l'instant (d√©commenter si Trivy install√©)
                        # Trivy = Scanner de vuln√©rabilit√©s pour images Docker
                        # docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                        #     aquasec/trivy:latest image \
                        #     --severity HIGH,CRITICAL \
                        #     ${DOCKER_IMAGE}:${VERSION}
                        
                        echo "‚úÖ Scan termin√©"
                    """
                }
            }
        }
        
        
        // ====================================================================
        // STAGE 6 : Validation (Test de l'image)
        // ====================================================================
        stage('‚úÖ Validation') {
            steps {
                echo '=== Test de l\'image Docker ==='
                
                script {
                    sh """
                        echo "üöÄ Lancement d'un conteneur de test..."
                        
                        # Lancer l'image cr√©√©e en mode d√©tach√©
                        docker run -d \
                            --name test-${BUILD_NUMBER} \     # Nom unique par build
                            -p 8888:8080 \                     # Port mapping
                            ${DOCKER_IMAGE}:${VERSION}
                        
                        # Attendre que l'app d√©marre
                        sleep 5
                        
                        # Faire un health check avec curl
                        echo "üè• Health check..."
                        # -f = Fail si HTTP error (4xx, 5xx)
                        # || exit 1 = Si curl √©choue, arr√™ter le pipeline
                        curl -f http://localhost:8888/health || exit 1
                        
                        echo "‚úÖ Image valid√©e !"
                        
                        # Nettoyer le conteneur de test
                        docker stop test-${BUILD_NUMBER}
                        docker rm test-${BUILD_NUMBER}
                    """
                }
            }
        }
        
    } // Fin des stages
    
    
    // ========================================================================
    // POST : Actions finales (apr√®s TOUS les stages)
    // ========================================================================
    post {
        // 'always' = Toujours ex√©cuter (succ√®s, √©chec, annulation)
        always {
            echo '=== Nettoyage ==='
            
            sh '''
                # Nettoyer tous les conteneurs de test qui restent
                # grep test- = Trouver les conteneurs avec "test-" dans le nom
                # awk '{print $1}' = Extraire l'ID du conteneur
                # xargs -r docker rm -f = Supprimer les conteneurs trouv√©s
                # || true = Ne pas √©chouer si aucun conteneur trouv√©
                docker ps -a | grep test- | awk '{print $1}' | xargs -r docker rm -f || true
                
                # Nettoyer les images Docker interm√©diaires (dangling)
                docker image prune -f
            '''
            
            // Nettoyer le workspace Jenkins (supprimer les fichiers du build)
            cleanWs()
        }
        
        // 'success' = Seulement si TOUT le pipeline a r√©ussi
        success {
            echo '‚úÖ‚úÖ‚úÖ PIPELINE R√âUSSI ! ‚úÖ‚úÖ‚úÖ'
            echo "Image: ${DOCKER_IMAGE}:${VERSION}"
            
            // Ici vous pourriez :
            // - Envoyer une notification Slack
            // - Push vers Docker Hub
            // - D√©clencher un d√©ploiement
        }
        
        // 'failure' = Si AU MOINS UN stage a √©chou√©
        failure {
            echo '‚ùå‚ùå‚ùå PIPELINE √âCHOU√â ! ‚ùå‚ùå‚ùå'
            
            // Ici vous pourriez :
            // - Envoyer un email d'alerte
            // - Cr√©er un ticket Jira
            // - Notifier l'√©quipe sur Slack
        }
        
        // 'unstable' = Tests ont √©chou√© mais build ok
        unstable {
            echo '‚ö†Ô∏è Pipeline instable (tests partiellement √©chou√©s)'
        }
        
        // Autres options post :
        // changed { ... }    ‚Üí Si le r√©sultat a chang√© depuis le dernier build
        // fixed { ... }      ‚Üí Si le build √©tait cass√© et est maintenant r√©par√©
        // regression { ... } ‚Üí Si le build √©tait ok et est maintenant cass√©
        // aborted { ... }    ‚Üí Si le build a √©t√© annul√© manuellement
    }
    
} // Fin du pipeline


// ============================================================================
// R√âSUM√â DES CONCEPTS CL√â
// ============================================================================

/*
1. STRUCTURE DECLARATIVE :
   pipeline { agent ‚Üí environment ‚Üí options ‚Üí stages ‚Üí post }

2. VARIABLES JENKINS AUTOMATIQUES :
   - ${env.BUILD_NUMBER}     ‚Üí Num√©ro du build (1, 2, 3...)
   - ${env.JOB_NAME}         ‚Üí Nom du job
   - ${env.WORKSPACE}        ‚Üí Chemin du workspace
   - ${env.BRANCH_NAME}      ‚Üí Nom de la branche Git
   - ${env.BUILD_URL}        ‚Üí URL du build dans Jenkins

3. SYNTAXE GROOVY :
   - Simple quotes '''  ‚Üí Pas d'interpolation
   - Double quotes """  ‚Üí Interpolation de variables ${...}
   - script { }         ‚Üí Bloc Groovy script√©
   - sh 'commande'      ‚Üí Ex√©cuter du shell
   - echo 'message'     ‚Üí Afficher dans les logs

4. DOCKER DANS JENKINS :
   - docker.image('...').inside { }  ‚Üí Lance un conteneur temporaire
   - √âquivalent √† : docker run --rm -v $(pwd):/workspace -w /workspace ...

5. POST ACTIONS :
   - always    ‚Üí Toujours
   - success   ‚Üí Si succ√®s
   - failure   ‚Üí Si √©chec
   - unstable  ‚Üí Si tests √©chou√©s
   - changed   ‚Üí Si r√©sultat diff√©rent du pr√©c√©dent
*/


// ============================================================================
// EXEMPLES D'UTILISATION AVANC√âE
// ============================================================================

/*
// Exemple 1 : Conditions avec 'when'
stage('Deploy to Prod') {
    when {
        branch 'main'  // Seulement si branche main
    }
    steps {
        sh './deploy.sh'
    }
}

// Exemple 2 : Stages parall√®les
stage('Tests') {
    parallel {
        stage('Unit Tests') {
            steps { sh 'pytest tests/unit' }
        }
        stage('E2E Tests') {
            steps { sh 'pytest tests/e2e' }
        }
    }
}

// Exemple 3 : Approbation manuelle
stage('Deploy') {
    steps {
        input message: 'D√©ployer ?', ok: 'Oui'
        sh './deploy.sh'
    }
}

// Exemple 4 : Credentials
environment {
    DOCKER_CREDS = credentials('dockerhub-credentials')
    // Cr√©e automatiquement :
    // - DOCKER_CREDS_USR (username)
    // - DOCKER_CREDS_PSW (password)
}

// Exemple 5 : Retry
stage('Deploy') {
    steps {
        retry(3) {  // R√©essayer 3 fois si √©chec
            sh './deploy.sh'
        }
    }
}
*/