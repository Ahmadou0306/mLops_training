// ============================================================================
// JENKINSFILE POUR PROJET AVEC DOCKER-COMPOSE
// Infrastructure MLOps complÃ¨te : API + PostgreSQL + MLflow + Monitoring
// ============================================================================

pipeline {
    agent any
    
    environment {
        // Configuration Docker
        COMPOSE_PROJECT_NAME = 'mlops-training'
        DOCKER_IMAGE = 'mlops-training'
        VERSION = "${env.BUILD_NUMBER}"
        
        // Configuration des services
        API_PORT = '8080'
        MLFLOW_PORT = '5000'
        GRAFANA_PORT = '3000'
        PROMETHEUS_PORT = '9090'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 45, unit: 'MINUTES')  // Plus de temps pour docker-compose
        timestamps()
    }
    
    stages {
        
        // ====================================================================
        // STAGE 1 : Checkout et PrÃ©paration
        // ====================================================================
        stage('ğŸ“¥ Checkout') {
            steps {
                echo '=== RÃ©cupÃ©ration du code depuis Git ==='
                checkout scm
                
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
                
                echo "ğŸ“Œ Commit: ${env.GIT_COMMIT_SHORT}"
                echo "ğŸ“Œ Build: #${env.BUILD_NUMBER}"
                
                // VÃ©rifier que docker-compose.yml existe
                sh '''
                    if [ ! -f docker-compose.yml ]; then
                        echo "âŒ docker-compose.yml introuvable !"
                        exit 1
                    fi
                    echo "âœ… docker-compose.yml trouvÃ©"
                '''
            }
        }
        
        // ====================================================================
        // STAGE 2 : Code Quality (dans un conteneur isolÃ©)
        // ====================================================================
        stage('ğŸ” Code Quality') {
            steps {
                echo '=== Analyse de la qualitÃ© du code ==='
                script {
                    docker.image('python:3.11-slim').inside {
                        sh '''
                            pip install flake8 black --quiet
                            
                            echo "ğŸ” Linting avec flake8..."
                            flake8 . --max-line-length=120 \
                                --exclude=venv,__pycache__,models \
                                || true
                            
                            echo "ğŸ¨ VÃ©rification du formatage..."
                            black --check . || echo "âš ï¸ Code pas formatÃ©"
                        '''
                    }
                }
            }
        }
        
        // ====================================================================
        // STAGE 3 : Tests Unitaires (avant de builder les services)
        // ====================================================================
        stage('ğŸ§ª Tests Unitaires') {
            steps {
                echo '=== ExÃ©cution des tests unitaires ==='
                script {
                    docker.image('python:3.11-slim').inside {
                        sh '''
                            pip install -r requirements.txt --quiet
                            pip install pytest pytest-cov --quiet
                            
                            mkdir -p reports
                            
                            echo "ğŸ§ª Tests unitaires..."
                            pytest test_app.py -v \
                                --junitxml=reports/junit.xml \
                                --cov=. \
                                --cov-report=html \
                                --cov-report=term-missing \
                                || echo "âš ï¸ Certains tests ont Ã©chouÃ©"
                        '''
                    }
                }
            }
            post {
                always {
                    junit 'reports/junit.xml'
                    publishHTML([
                        reportDir: 'htmlcov',
                        reportFiles: 'index.html',
                        reportName: 'Code Coverage',
                        keepAll: true
                    ])
                }
            }
        }
        
        // ====================================================================
        // STAGE 4 : Nettoyage des Services Existants
        // ====================================================================
        stage('ğŸ§¹ Cleanup') {
            steps {
                echo '=== Nettoyage des services existants ==='
                sh '''
                    echo "ğŸ›‘ ArrÃªt des services existants..."
                    docker-compose down --volumes --remove-orphans || true
                    
                    echo "ğŸ—‘ï¸ Nettoyage des anciennes images..."
                    docker image prune -f || true
                    
                    echo "âœ… Nettoyage terminÃ©"
                '''
            }
        }
        
        // ====================================================================
        // STAGE 5 : Build de l'Image Docker de l'API
        // ====================================================================
        stage('ğŸ³ Build Docker Image') {
            steps {
                echo '=== Construction de l\'image Docker de l\'API ==='
                script {
                    sh """
                        echo "ğŸ”¨ Build de l'image model-api..."
                        docker build \
                            -t ${DOCKER_IMAGE}:${VERSION} \
                            -t ${DOCKER_IMAGE}:latest \
                            --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                            --build-arg VCS_REF=${env.GIT_COMMIT_SHORT} \
                            .
                    """
                    
                    echo "âœ… Image crÃ©Ã©e: ${DOCKER_IMAGE}:${VERSION}"
                    sh "docker images | grep ${DOCKER_IMAGE} | head -3"
                }
            }
        }
        
        // ====================================================================
        // STAGE 6 : Lancement des Services avec Docker Compose
        // ====================================================================
        stage('ğŸš€ Start Services') {
            steps {
                echo '=== DÃ©marrage des services Docker Compose ==='
                sh '''
                    echo "ğŸš€ Lancement de tous les services..."
                    
                    # Lancer en mode dÃ©tachÃ©
                    docker-compose up -d
                    
                    echo "â³ Attente du dÃ©marrage des services (30s)..."
                    sleep 30
                    
                    echo "ğŸ“Š Ã‰tat des services:"
                    docker-compose ps
                '''
            }
        }
        
        // ====================================================================
        // STAGE 7 : Health Checks de Tous les Services
        // ====================================================================
        stage('ğŸ¥ Health Checks') {
            steps {
                echo '=== VÃ©rification de la santÃ© des services ==='
                script {
                    sh '''
                        echo "==================================="
                        echo "ğŸ” Health Check des Services"
                        echo "==================================="
                        
                        # Fonction de health check
                        check_service() {
                            local service=$1
                            local url=$2
                            local max_attempts=10
                            local attempt=1
                            
                            echo ""
                            echo "ğŸ“¡ Test de $service sur $url"
                            
                            while [ $attempt -le $max_attempts ]; do
                                if curl -f -s "$url" > /dev/null 2>&1; then
                                    echo "âœ… $service est UP (tentative $attempt/$max_attempts)"
                                    return 0
                                fi
                                echo "â³ Attente $service... (tentative $attempt/$max_attempts)"
                                sleep 5
                                attempt=$((attempt + 1))
                            done
                            
                            echo "âŒ $service n'a pas dÃ©marrÃ© aprÃ¨s $max_attempts tentatives"
                            return 1
                        }
                        
                        # VÃ©rifier chaque service
                        HEALTH_CHECK_FAILED=0
                        
                        # 1. API Model
                        check_service "Model API" "http://localhost:8080/health" || HEALTH_CHECK_FAILED=1
                        
                        # 2. PostgreSQL (via pg_isready)
                        echo ""
                        echo "ğŸ“¡ Test de PostgreSQL"
                        if docker-compose exec -T postgres pg_isready -U admin > /dev/null 2>&1; then
                            echo "âœ… PostgreSQL est UP"
                        else
                            echo "âŒ PostgreSQL n'est pas disponible"
                            HEALTH_CHECK_FAILED=1
                        fi
                        
                        # 3. MLflow
                        check_service "MLflow" "http://localhost:5000" || HEALTH_CHECK_FAILED=1
                        
                        # 4. Prometheus
                        check_service "Prometheus" "http://localhost:9090/-/healthy" || HEALTH_CHECK_FAILED=1
                        
                        # 5. Grafana
                        check_service "Grafana" "http://localhost:3000/api/health" || HEALTH_CHECK_FAILED=1
                        
                        echo ""
                        echo "==================================="
                        if [ $HEALTH_CHECK_FAILED -eq 0 ]; then
                            echo "âœ… Tous les services sont UP !"
                        else
                            echo "âŒ Certains services ont Ã©chouÃ©"
                            echo "ğŸ“‹ Logs des services:"
                            docker-compose logs --tail=50
                            exit 1
                        fi
                        echo "==================================="
                    '''
                }
            }
        }
        
        // ====================================================================
        // STAGE 8 : Tests d'IntÃ©gration (API + Services)
        // ====================================================================
        stage('ğŸ§ª Tests d\'IntÃ©gration') {
            steps {
                echo '=== Tests d\'intÃ©gration de la stack complÃ¨te ==='
                script {
                    sh '''
                        echo "ğŸ§ª Tests d'intÃ©gration..."
                        
                        # Test 1 : Endpoint de prÃ©diction de l'API
                        echo ""
                        echo "ğŸ“ Test 1: Endpoint /predict"
                        RESPONSE=$(curl -s -X POST http://localhost:8080/predict \
                            -H "Content-Type: application/json" \
                            -d '{"features": [1, 2, 3, 4, 5]}' \
                            -w "\n%{http_code}")
                        
                        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
                        BODY=$(echo "$RESPONSE" | head -n-1)
                        
                        if [ "$HTTP_CODE" = "200" ]; then
                            echo "âœ… API rÃ©pond correctement"
                            echo "   Response: $BODY"
                        else
                            echo "âŒ API erreur (HTTP $HTTP_CODE)"
                            echo "   Response: $BODY"
                            exit 1
                        fi
                        
                        # Test 2 : VÃ©rifier que MLflow enregistre les expÃ©riences
                        echo ""
                        echo "ğŸ“ Test 2: MLflow tracking"
                        MLFLOW_EXPERIMENTS=$(curl -s http://localhost:5000/api/2.0/mlflow/experiments/list)
                        if echo "$MLFLOW_EXPERIMENTS" | grep -q "experiments"; then
                            echo "âœ… MLflow tracking fonctionne"
                        else
                            echo "âš ï¸ MLflow tracking: pas d'expÃ©riences (normal au premier lancement)"
                        fi
                        
                        # Test 3 : VÃ©rifier les mÃ©triques Prometheus
                        echo ""
                        echo "ğŸ“ Test 3: Prometheus metrics"
                        PROM_METRICS=$(curl -s http://localhost:9090/api/v1/query?query=up)
                        if echo "$PROM_METRICS" | grep -q "success"; then
                            echo "âœ… Prometheus collecte des mÃ©triques"
                        else
                            echo "âš ï¸ Prometheus: mÃ©triques non disponibles"
                        fi
                        
                        # Test 4 : Base de donnÃ©es PostgreSQL
                        echo ""
                        echo "ğŸ“ Test 4: PostgreSQL connectivity"
                        if docker-compose exec -T postgres psql -U admin -d mlflow -c "SELECT 1;" > /dev/null 2>&1; then
                            echo "âœ… PostgreSQL accepte les connexions"
                        else
                            echo "âŒ PostgreSQL connexion Ã©chouÃ©e"
                            exit 1
                        fi
                        
                        echo ""
                        echo "âœ… Tous les tests d'intÃ©gration passÃ©s !"
                    '''
                }
            }
        }
        
        // ====================================================================
        // STAGE 9 : Performance / Load Test (Optionnel)
        // ====================================================================
        stage('âš¡ Load Test') {
            when {
                branch 'main'  // Seulement sur la branche main
            }
            steps {
                echo '=== Test de charge de l\'API ==='
                script {
                    sh '''
                        echo "âš¡ Test de charge avec Apache Bench..."
                        
                        # Installer ab si nÃ©cessaire
                        if ! command -v ab &> /dev/null; then
                            echo "Installation d'Apache Bench..."
                            apt-get update && apt-get install -y apache2-utils || \
                            apk add apache2-utils || \
                            echo "âš ï¸ ab non disponible, skip load test"
                        fi
                        
                        # Test de charge : 100 requÃªtes, 10 concurrentes
                        if command -v ab &> /dev/null; then
                            echo "ğŸš€ 100 requÃªtes, 10 concurrentes sur /health"
                            ab -n 100 -c 10 http://localhost:8080/health || echo "âš ï¸ Load test failed"
                        fi
                    '''
                }
            }
        }
        
        // ====================================================================
        // STAGE 10 : Collecte des Logs et MÃ©triques
        // ====================================================================
        stage('ğŸ“Š Collect Metrics') {
            steps {
                echo '=== Collecte des logs et mÃ©triques ==='
                sh '''
                    echo "ğŸ“Š Statistiques des conteneurs:"
                    docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"
                    
                    echo ""
                    echo "ğŸ“‹ Logs rÃ©cents de chaque service:"
                    
                    echo "--- Model API ---"
                    docker-compose logs --tail=20 model-api
                    
                    echo "--- MLflow ---"
                    docker-compose logs --tail=20 mlflow
                    
                    echo "--- PostgreSQL ---"
                    docker-compose logs --tail=10 postgres
                '''
            }
        }
        
        // ====================================================================
        // STAGE 11 : DÃ©cision de DÃ©ploiement (Manuel pour Production)
        // ====================================================================
        stage('ğŸš¢ Deploy Decision') {
            when {
                branch 'main'
            }
            steps {
                script {
                    // Seulement pour la branche main, demander confirmation
                    def userInput = input(
                        id: 'DeployApproval',
                        message: 'âœ… Tests passÃ©s ! Garder les services actifs ?',
                        parameters: [
                            choice(
                                name: 'ACTION',
                                choices: ['Keep Running (Dev/Staging)', 'Stop Services', 'Tag for Production'],
                                description: 'Que faire avec les services ?'
                            )
                        ]
                    )
                    
                    echo "ğŸ‘¤ DÃ©cision utilisateur: ${userInput}"
                    
                    if (userInput == 'Stop Services') {
                        echo "ğŸ›‘ ArrÃªt des services..."
                        sh 'docker-compose down'
                    } else if (userInput == 'Tag for Production') {
                        echo "ğŸ·ï¸ Tagging pour production..."
                        sh """
                            docker tag ${DOCKER_IMAGE}:${VERSION} ${DOCKER_IMAGE}:production
                            echo "âœ… Tagged as production"
                        """
                    } else {
                        echo "âœ… Services restent actifs"
                    }
                }
            }
        }
    }
    
    // ========================================================================
    // POST : Actions finales
    // ========================================================================
    post {
        always {
            echo '=== RÃ©sumÃ© de l\'exÃ©cution ==='
            script {
                sh '''
                    echo "ğŸ“Š Ã‰tat final des services:"
                    docker-compose ps || echo "Services arrÃªtÃ©s"
                    
                    echo ""
                    echo "ğŸ³ Images Docker crÃ©Ã©es:"
                    docker images | grep mlops-training || echo "Aucune image"
                '''
            }
        }
        
        success {
            echo 'âœ…âœ…âœ… PIPELINE RÃ‰USSI ! âœ…âœ…âœ…'
            echo """
            ğŸ‰ Stack MLOps dÃ©ployÃ©e avec succÃ¨s !
            
            ğŸ“ Services disponibles:
               â€¢ API Model:     http://localhost:8080
               â€¢ MLflow:        http://localhost:5000
               â€¢ Grafana:       http://localhost:3000 (admin/admin)
               â€¢ Prometheus:    http://localhost:9090
            
            ğŸ³ Image: ${DOCKER_IMAGE}:${VERSION}
            ğŸ“Œ Commit: ${env.GIT_COMMIT_SHORT}
            """
        }
        
        failure {
            echo 'âŒâŒâŒ PIPELINE Ã‰CHOUÃ‰ ! âŒâŒâŒ'
            echo 'RÃ©cupÃ©ration des logs pour debug...'
            
            sh '''
                echo "ğŸ“‹ Logs des services en erreur:"
                docker-compose logs --tail=100 || echo "Pas de logs disponibles"
                
                echo ""
                echo "ğŸ³ Ã‰tat des conteneurs:"
                docker-compose ps -a || echo "Aucun conteneur"
            '''
            
            // Nettoyer en cas d'Ã©chec
            sh 'docker-compose down --volumes || true'
        }
        
        unstable {
            echo 'âš ï¸ Pipeline instable'
            echo 'Certains tests ont Ã©chouÃ© mais le build a continuÃ©'
        }
        
        cleanup {
            // Nettoyage final (optionnel)
            echo 'ğŸ§¹ Nettoyage final...'
            sh '''
                # Nettoyer les images dangling
                docker image prune -f || true
                
                # Nettoyer les volumes orphelins (attention en prod !)
                # docker volume prune -f || true
            '''
        }
    }
}


// ============================================================================
// NOTES D'UTILISATION
// ============================================================================

/*
ğŸ“‹ PRÃ‰REQUIS:
1. Docker et Docker Compose installÃ©s sur l'agent Jenkins
2. Ports disponibles: 8080, 5000, 3000, 9090, 5432
3. Fichiers requis dans le repo:
   - docker-compose.yml
   - Dockerfile
   - requirements.txt
   - test_app.py
   - prometheus.yml (pour Prometheus)

ğŸ”§ CONFIGURATION JENKINS:
1. CrÃ©er le job Pipeline
2. Configure â†’ Pipeline â†’ Pipeline script from SCM
3. Repository: votre repo Git
4. Script Path: Jenkinsfile

ğŸš€ WORKFLOW:
1. Push vers Git â†’ Jenkins dÃ©tecte
2. Tests unitaires dans un conteneur isolÃ©
3. Build de l'image Docker
4. Lancement de toute la stack avec docker-compose
5. Health checks de tous les services
6. Tests d'intÃ©gration
7. DÃ©cision manuelle de dÃ©ploiement

âš™ï¸ VARIABLES Ã€ PERSONNALISER:
- COMPOSE_PROJECT_NAME: nom de votre projet
- Ports des services (si conflits)
- Timeouts des health checks

ğŸ” SÃ‰CURITÃ‰:
En production, stockez les credentials dans Jenkins:
- PostgreSQL password
- Grafana admin password
- API tokens
Utilisez credentials() dans environment{}

ğŸ“Š MONITORING:
AccÃ©dez aux dashboards:
- Grafana: http://localhost:3000 (admin/admin)
- Prometheus: http://localhost:9090
- MLflow: http://localhost:5000

ğŸ›‘ ARRÃŠT MANUEL:
docker-compose down --volumes

ğŸ’¾ BACKUP:
docker-compose exec postgres pg_dump -U admin mlflow > backup.sql
*/
